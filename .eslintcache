[{"C:\\Users\\ankur\\Documents\\GitHub\\DataStructureAndAlgorithmsMadeEasyInJavaScript\\madeeasy\\chapter 02.js":"1","C:\\Users\\ankur\\Documents\\GitHub\\DataStructureAndAlgorithmsMadeEasyInJavaScript\\madeeasy\\chapter 03.js":"2","C:\\Users\\ankur\\Documents\\GitHub\\DataStructureAndAlgorithmsMadeEasyInJavaScript\\madeeasy\\chapter 04.js":"3","C:\\Users\\ankur\\Documents\\GitHub\\DataStructureAndAlgorithmsMadeEasyInJavaScript\\madeeasy\\chapter 05.js":"4","C:\\Users\\ankur\\Documents\\GitHub\\DataStructureAndAlgorithmsMadeEasyInJavaScript\\madeeasy\\chapter 10.js":"5","C:\\Users\\ankur\\Documents\\GitHub\\DataStructureAndAlgorithmsMadeEasyInJavaScript\\madeeasy\\chapter 11.js":"6","C:\\Users\\ankur\\Documents\\GitHub\\DataStructureAndAlgorithmsMadeEasyInJavaScript\\madeeasy\\chapter 19.js":"7"},{"size":1616,"mtime":1568019385157,"results":"8","hashOfConfig":"9"},{"size":19162,"mtime":1628950953043,"results":"10","hashOfConfig":"9"},{"size":16512,"mtime":1628952507457,"results":"11","hashOfConfig":"9"},{"size":5064,"mtime":1628952865629,"results":"12","hashOfConfig":"9"},{"size":9261,"mtime":1552530590244,"results":"13","hashOfConfig":"9"},{"size":8487,"mtime":1552530590245,"results":"14","hashOfConfig":"9"},{"size":3805,"mtime":1568096954772,"results":"15","hashOfConfig":"9"},{"filePath":"16","messages":"17","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"vymg66",{"filePath":"18","messages":"19","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"20","messages":"21","errorCount":22,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"22"},{"filePath":"23","messages":"24","errorCount":6,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"25","messages":"26","errorCount":14,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"27"},{"filePath":"28","messages":"29","errorCount":35,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"30"},{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"C:\\Users\\ankur\\Documents\\GitHub\\DataStructureAndAlgorithmsMadeEasyInJavaScript\\madeeasy\\chapter 02.js",[],"C:\\Users\\ankur\\Documents\\GitHub\\DataStructureAndAlgorithmsMadeEasyInJavaScript\\madeeasy\\chapter 03.js",[],"C:\\Users\\ankur\\Documents\\GitHub\\DataStructureAndAlgorithmsMadeEasyInJavaScript\\madeeasy\\chapter 04.js",["33","34","35","36","37","38","39","40","41","42","43","44","45","46","47","48","49","50","51","52","53","54"],"import { ListNode } from './chapter 03';\n// 4.6 Implementation\n// Simple Array Implementation of Stack\nfunction ArrayStack(size) {\n  // private\n  let top = -1;\n  const capacity = size;\n  const array = [];\n  return {\n    isEmpty() {\n      return (top === -1);\n    },\n    isStackFull() {\n      return (top === (capacity - 1));\n    },\n    pushInStack(data) {\n      if (this.isStackFull()) {\n        console.error('Stack Overflow');\n      } else {\n        array[++top] = data;\n      }\n    },\n    popFromStack() {\n      if (this.isEmpty()) {\n        console.error('Stack is Empty');\n        return;\n      }\n      return array[top--];\n    },\n  };\n}\n\n// Dynamic Array Implementation of Stack\n// In JavaScript, array is already dynamic in nature\nfunction DynArrayStack(size) {\n  // private\n  let top = -1;\n  let capacity = size;\n  const array = [];\n  return {\n    isEmpty() {\n      return top === -1;\n    },\n    isStackFull() {\n      return top === capacity - 1;\n    },\n    doubleStack() {\n      capacity *= 2;\n    },\n    deleteStack() {\n      top = -1;\n    },\n    pushInStack(data) {\n      if (this.isStackFull()) {\n        this.doubleStack();\n      }\n      array[++top] = data;\n    },\n    popFromStack() {\n      if (this.isEmpty()) {\n        console.error('Stack is Empty');\n        return;\n      }\n      return array[top--];\n    },\n  };\n}\n\n// Linked list implementation of Stack\nfunction LLStack() {\n  let temp;\n  let llNode;\n  let headNode = new ListNode();\n\n  return {\n    top() {\n      if (!headNode) {\n        return null;\n      }\n      return headNode.getData();\n    },\n    isEmpty() {\n      if (!headNode || !headNode.getData()) { return true; }\n      return false;\n    },\n    deleteStack() {\n      headNode = null;\n    },\n    pushInStack(data) {\n      if (!headNode) {\n        headNode = new ListNode();\n        headNode.setData(data);\n      } else if (!headNode.getData()) {\n        headNode.setData(data);\n      } else {\n        llNode = new ListNode();\n        llNode.setData(data);\n        llNode.setNext(headNode);\n        headNode = llNode;\n      }\n    },\n    popFromStack() {\n      if (headNode === null) {\n        console.error('Stack is Empty');\n        return;\n      }\n      temp = headNode.getData();\n      headNode = headNode.getNext();\n      return temp;\n    },\n  };\n}\n\n//----------\n// Problem-2 Infix to Postfix conversion using stack\nfunction infix2postfix(infix) {\n  let i;\n  let bwParnt;\n  let postfix = '';\n  const operator = new LLStack();\n  for (i = 0; i < infix.length; i++) {\n    if ((infix.charCodeAt(i) >= 32 && infix.charCodeAt(i) <= 47)\n            || (infix.charCodeAt(i) >= 58 && infix.charCodeAt(i) <= 64)\n            || (infix.charCodeAt(i) >= 91 && infix.charCodeAt(i) <= 96)\n            || (infix.charCodeAt(i) >= 123 && infix.charCodeAt(i) <= 126)) {\n      if (infix[i] === ')') {\n        bwParnt = operator.popFromStack();\n        while (bwParnt !== '(') {\n          postfix += bwParnt;\n          bwParnt = operator.popFromStack();\n        }\n      } else {\n        operator.pushInStack(infix[i]);\n      }\n    } else {\n      postfix += infix[i];\n    }\n  }\n  while (!operator.isEmpty()) {\n    postfix += operator.popFromStack();\n  }\n  return postfix;\n}\n\n//----------\n// Problem-4 Postfix evaluation using stack\nfunction postfixEvaluation(postfix) {\n  let i;\n  const operand = new LLStack();\n  let evaluate;\n  let operand1;\n  let operand2;\n  for (i = 0; i < postfix.length; i++) {\n    if ((postfix.charCodeAt(i) >= 32 && postfix.charCodeAt(i) <= 47)\n            || (postfix.charCodeAt(i) >= 58 && postfix.charCodeAt(i) <= 64)\n            || (postfix.charCodeAt(i) >= 91 && postfix.charCodeAt(i) <= 96)\n            || (postfix.charCodeAt(i) >= 123 && postfix.charCodeAt(i) <= 126)) {\n      operand1 = parseInt(operand.popFromStack(), 10);\n      operand2 = parseInt(operand.popFromStack(), 10);\n      switch (postfix[i]) {\n        case '+':\n          evaluate = operand2 + operand1;\n          break;\n        case '-':\n          evaluate = operand2 - operand1;\n          break;\n        case '*':\n          evaluate = operand2 * operand1;\n          break;\n        case '/':\n          evaluate = operand2 / operand1;\n          break;\n        default:\n          console.error(\"Doesn't support oprand other then +, -, *, / \");\n          break;\n      }\n      operand.pushInStack(evaluate);\n    } else {\n      operand.pushInStack(postfix[i]);\n    }\n  }\n  return operand.popFromStack();\n}\n\n//----------\n// Problem-5 Infix evaluation using 2 stacks\nfunction infixEvaluation(infix) {\n  let i;\n  let bwParnt;\n  let evaluate;\n  let operand1;\n  let operand2;\n  const operand = new LLStack();\n  const operator = new LLStack();\n  for (i = 0; i < infix.length; i++) {\n    if ((infix.charCodeAt(i) >= 32 && infix.charCodeAt(i) <= 47)\n            || (infix.charCodeAt(i) >= 58 && infix.charCodeAt(i) <= 64)\n            || (infix.charCodeAt(i) >= 91 && infix.charCodeAt(i) <= 96)\n            || (infix.charCodeAt(i) >= 123 && infix.charCodeAt(i) <= 126)) {\n      if (infix[i] === ')') {\n        bwParnt = operator.popFromStack();\n        while (bwParnt !== '(') {\n          operand1 = parseInt(operand.popFromStack(), 10);\n          operand2 = parseInt(operand.popFromStack(), 10);\n          switch (operator.popFromStack()) {\n            case '+':\n              evaluate = operand2 + operand1;\n              break;\n            case '-':\n              evaluate = operand2 - operand1;\n              break;\n            case '*':\n              evaluate = operand2 * operand1;\n              break;\n            case '/':\n              evaluate = operand2 / operand1;\n              break;\n            default:\n              console.error(\"Doesn't support oprand other then +, -, *, / \");\n              break;\n          }\n          operand.pushInStack(evaluate);\n          bwParnt = operator.popFromStack();\n        }\n      } else {\n        operator.pushInStack(infix[i]);\n      }\n    } else {\n      operand.pushInStack(infix[i]);\n    }\n  }\n  while (!operator.isEmpty()) {\n    operand1 = parseInt(operand.popFromStack(), 10);\n    operand2 = parseInt(operand.popFromStack(), 10);\n    switch (operator.popFromStack()) {\n      case '+':\n        evaluate = operand2 + operand1;\n        break;\n      case '-':\n        evaluate = operand2 - operand1;\n        break;\n      case '*':\n        evaluate = operand2 * operand1;\n        break;\n      case '/':\n        evaluate = operand2 / operand1;\n        break;\n      default:\n        console.error(\"Doesn't support oprand other then +, -, *, / \");\n        break;\n    }\n    operand.pushInStack(evaluate);\n  }\n  return operand.popFromStack();\n}\n\n//----------\n// Problem-6 How to design a stack such that getMinimum() should be O(1)?\nfunction advancedStack() {\n  const elementStack = new LLStack();\n  const minStack = new LLStack();\n  return {\n    pushInAdvancedStack(data) {\n      elementStack.pushInStack(data);\n      if (minStack.isEmpty() || minStack.top() >= data) {\n        minStack.pushInStack(data);\n      } else {\n        minStack.pushInStack(minStack.top());\n      }\n    },\n    popFromAdvancedStack() {\n      if (elementStack.isEmpty()) {\n        console.error('Advanced stack is empty');\n        return;\n      }\n      minStack.popFromStack();\n      return elementStack.popFromStack();\n    },\n    getMinimum() {\n      return minStack.top();\n    },\n    getTop() {\n      return elementStack.top();\n    },\n  };\n}\n\n//----------\n// Problem-7 For the Problem-6 is it possible to improve the space complexity?\nfunction improvedStack() {\n  let minTop;\n  let elementTop;\n  const elementStack = new LLStack();\n  const minStack = new LLStack();\n  return {\n    pushInImprovedStack(data) {\n      elementStack.pushInStack(data);\n      if (minStack.isEmpty() || minStack.top() >= data) {\n        minStack.pushInStack(data);\n      }\n    },\n    popFromImprovedStack() {\n      if (elementStack.isEmpty()) {\n        console.log('Improved stack is empty');\n        return;\n      }\n      minTop = minStack.top();\n      elementTop = elementStack.top();\n      if (minTop === elementTop) {\n        minStack.popFromStack();\n      }\n      return elementStack.popFromStack();\n    },\n    getMinimum() {\n      return minStack.top();\n    },\n    getTop() {\n      return elementStack.top();\n    },\n  };\n}\n\n//----------\n// Problem-8 Given an array of characters formed with a's and b's. The string is marked with special character X\n// which represents the middle of the list. Check whether the string is palindrome or not?\nfunction isPalindrome(inputStr) {\n  let i = 0;\n  let j = inputStr.length - 1;\n  while ((i < j) && (inputStr[i] === inputStr[j])) {\n    i++;\n    j--;\n  }\n  if (i < j) {\n    console.error('Not a Palindrome');\n    return 0;\n  }\n  console.log('Palindrome');\n  return 1;\n}\n\n//----------\n// Problem-10 Can we solve Problem-8 using stacks?\nfunction isPalindromeUsingStack(inputStr) {\n  let i = 0;\n  const stack = new LLStack();\n  while (inputStr[i] !== 'X') {\n    stack.pushInStack(inputStr[i++]);\n  }\n  i++;\n  while (i < inputStr.length) {\n    if (stack.isEmpty()) {\n      return false;\n    }\n    if (inputStr[i++] !== stack.popFromStack()) {\n      return false;\n    }\n  }\n  return true;\n}\n\n//----------\n// Problem-11 Given a stack, how to reverse the contents of stacks by using only stack operations (push and pop)?\nfunction stackReversal() {\n  // private\n  function insertAtBottom(stack, data) {\n    if (stack.isEmpty()) {\n      stack.pushInStack(data);\n      return;\n    }\n    const temp = stack.popFromStack();\n    this.insertAtBottom(stack, data);\n    stack.pushInStack(temp);\n  }\n  return {\n    // public\n    reverseStack(stack) {\n      if (stack.isEmpty()) return;\n      const temp = stack.popFromStack();\n      this.reverseStack(stack);\n      insertAtBottom(stack, temp);\n    },\n  };\n}\n\n//----------\n// Problem-14 How do we implement 2 stack using only one array? Our stack routines shoulf not indicate an exception\n// unless every slot in the array is used?\nfunction arrayWithTwoStack(size) {\n  const dataArray = [];\n  let topOne = -1;\n  let topTwo = size;\n  return {\n    pushInStack(stackId, data) {\n      if (topTwo === topOne + 1) {\n        console.error('Array is full');\n        return;\n      }\n      if (stackId === 1) {\n        dataArray[++topOne] = data;\n      } else if (stackId === 2) {\n        dataArray[--topTwo] = data;\n      }\n    },\n\n    popFromStack(stackId) {\n      if (stackId === 1) {\n        if (topOne === -1) {\n          console.error('First Stack is empty');\n          return;\n        }\n        const top = dataArray[topOne];\n        dataArray[topOne--] = null;\n        return top;\n      } if (stackId === 2) {\n        if (topTwo === size) {\n          console.error('Second Stack is empty');\n          return;\n        }\n        const top = dataArray[topTwo];\n        dataArray[topTwo++] = null;\n        return top;\n      } return null;\n    },\n\n    top(stackId) {\n      if (stackId === 1) {\n        if (topOne === -1) {\n          console.error('First Stack is empty');\n          return;\n        }\n        return dataArray[topOne];\n      } if (stackId === 2) {\n        if (topTwo === size) {\n          console.error('Second Stack is empty');\n          return;\n        }\n        return dataArray[topTwo];\n      } return null;\n    },\n\n    isEmpty(stackId) {\n      if (stackId === 1) {\n        return topOne === -1;\n      } if (stackId === size) {\n        return topTwo === size;\n      } return null;\n    },\n  };\n}\n\n//----------\n// Problem-15 How do we implement 3 stack in one array?\nfunction arrayWithThreeStack(size) {\n  const dataArray = [];\n  let topOne = -1;\n  let topTwo = size;\n  let topThree = size / 2;\n  let baseThree = topThree;\n\n  function stack3IsLeftShiftable() {\n    if (topOne + 1 < baseThree) {\n      return true;\n    }\n    return false;\n  }\n\n  function shiftStack3Left() {\n    for (let i = baseThree - 1; i < topThree; i++) {\n      dataArray[i] = dataArray[i + 1];\n    }\n    console.log('Left shifted');\n    dataArray[topThree--] = null;\n    baseThree--;\n  }\n\n  function stack3IsRightShiftable() {\n    if (topTwo - 1 > topThree) {\n      return true;\n    }\n    return false;\n  }\n\n  function shiftStack3Right() {\n    for (let i = topThree + 1; i > baseThree; i--) {\n      dataArray[i] = dataArray[i - 1];\n    }\n    console.log('Right shifted');\n    dataArray[baseThree++] = null;\n    topThree++;\n  }\n\n  return {\n    pushInStack(stackId, data) {\n      if (stackId === 1) {\n        if (topOne + 1 === baseThree) {\n          if (stack3IsRightShiftable()) {\n            shiftStack3Right();\n            dataArray[++topOne] = data;\n          } else {\n            console.error('Stack 1 is reached its maximum limit');\n            return;\n          }\n        } else {\n          dataArray[++topOne] = data;\n        }\n      }\n      if (stackId === 2) {\n        if (topTwo - 1 === topThree) {\n          if (stack3IsLeftShiftable()) {\n            shiftStack3Left();\n            dataArray[--topTwo] = data;\n          } else {\n            console.error('Stack 2 is reached its maximum limit');\n            return;\n          }\n        } else {\n          dataArray[--topTwo] = data;\n        }\n      }\n      if (stackId === 3) {\n        if (topTwo - 1 === topThree) {\n          if (stack3IsLeftShiftable()) {\n            shiftStack3Left();\n            dataArray[++topThree] = data;\n          } else {\n            console.error('Stack 3 is reached its maximum limit');\n          }\n        } else {\n          dataArray[++topThree] = data;\n        }\n      }\n    },\n\n    popFromStack(stackId) {\n      if (stackId === 1) {\n        if (topOne === -1) {\n          console.error('First Stack is empty');\n          return;\n        }\n        const top = dataArray[topOne];\n        dataArray[topOne--] = null;\n        return top;\n      } if (stackId === 2) {\n        if (topTwo === size) {\n          console.error('Second Stack is empty');\n          return;\n        }\n        const top = dataArray[topTwo];\n        dataArray[topTwo++] = null;\n        return top;\n      } if (stackId === 3) {\n        if (topThree === size && dataArray[topThree] === null) {\n          console.error('Third Stack is empty');\n          return;\n        }\n        const top = dataArray[topThree];\n        if (topThree > baseThree) {\n          dataArray[topThree--] = null;\n        }\n        if (topThree === baseThree) {\n          dataArray[topThree] = null;\n        }\n        return top;\n      } return null;\n    },\n\n    top(stackId) {\n      if (stackId === 1) {\n        if (topOne === -1) {\n          console.error('First Stack is empty');\n          return;\n        }\n        return dataArray[topOne];\n      } if (stackId === 2) {\n        if (topTwo === size) {\n          console.error('Second Stack is empty');\n          return;\n        }\n        return dataArray[topTwo];\n      } if (stackId === 3) {\n        if (topThree === baseThree && dataArray[baseThree] === null) {\n          console.error('Third Stack is empty');\n          return;\n        }\n        return dataArray[topThree];\n      } return null;\n    },\n\n    isEmpty(stackId) {\n      if (stackId === 1) {\n        return topOne === -1;\n      } if (stackId === size) {\n        return topTwo === size;\n      } if (stackId === 3) {\n        return (topThree === baseThree && dataArray[baseThree] === null);\n      } return null;\n    },\n  };\n}\n\n//----------\n// Problem-17 Multiple (m) stack in one array: As similar to Problem-15, what if we want to implement m stacks in one array?\nfunction arrayWithMultipleStack(size, m) {\n  const dataArray = [];\n  const base = [];\n  let top = [];\n\n  if (size < m) {\n    console.error(`Size <${m} is not possible`);\n    return;\n  }\n\n  return {\n    pushInStack(stackId, data) {\n      for (let i = 0; i < size; i++) {\n        if (top[i] === base[i + 1]) {\n          // Print ith Stack is full and does the shifting\n          // TO-DO\n        } else {\n          dataArray[++top[i]] = data;\n        }\n      }\n    },\n\n    popFromStack(stackId) {\n      for (let i = 0; i < size; i++) {\n        if (top[i] === base[i]) {\n          console.error('Stack is empty');\n          return;\n        }\n        top = dataArray[top[i]];\n        dataArray[top[i]--] = null;\n        return top;\n      }\n    },\n\n    top(stackId) {\n      // TO-DO\n    },\n\n    isEmpty(stackId) {\n      // TO-DO\n    },\n  };\n}\n\n// Problem-18 Consider an empty stack of integers. Let the numbers 1,2,3,4,5,6 be pushed on to this stack only in the order they appear from left to right.\n// Let S indicates a push and X indicates a pop operation. Can the be permuted in to the order? If so, then give the order string of operation.\n","C:\\Users\\ankur\\Documents\\GitHub\\DataStructureAndAlgorithmsMadeEasyInJavaScript\\madeeasy\\chapter 05.js",["55","56","57","58","59","60"],"C:\\Users\\ankur\\Documents\\GitHub\\DataStructureAndAlgorithmsMadeEasyInJavaScript\\madeeasy\\chapter 10.js",["61","62","63","64","65","66","67","68","69","70","71","72","73","74"],"function getMax(array) {\n  let i;\n  let max = array[0];\n  for (i = 1; i < array.length; i++) {\n    if (max < array[i]) {\n      max = array[i];\n    }\n  }\n  return max;\n}\n\nfunction swap(array, left, right) {\n  const temp = array[left];\n  array[left] = array[right];\n  array[right] = temp;\n}\n\n// 10.5 Bubble sort\nfunction bubbleSort(array) {\n  let i;\n  let pass;\n  const { length } = array;\n  for (pass = length - 1; pass >= 0; pass--) {\n    for (i = 0; i < pass; i++) {\n      if (array[i] > array[i + 1]) {\n        swap(array, i, i + 1);\n      }\n    }\n  }\n}\n\n// Above algorithm takes O(n^2) even in best case. We can improve it using an extra flag\n// The only case where we can skip the remaining pass if array is already sorted. Best case O(n).\nfunction bubbleSortImproved(array) {\n  let i;\n  let pass;\n  let swapped = 1;\n  const { length } = array;\n  for (pass = length - 1; pass >= 0 && swapped; pass--) {\n    swapped = 0;\n    for (i = 0; i < pass; i++) {\n      if (array[i] > array[i + 1]) {\n        swap(array, i, i + 1);\n        swapped = 1;\n      }\n    }\n  }\n}\n\n// 10.6 Selection sort\nfunction selectionSort(array) {\n  let i;\n  let pass;\n  let min;\n  const { length } = array;\n  for (pass = 0; pass < length - 1; pass++) {\n    min = pass;\n    for (i = pass + 1; i < length; i++) {\n      if (array[i] < array[min]) {\n        min = i;\n      }\n    }\n    swap(array, min, pass);\n  }\n}\n\n// 10.7 Insertion sort\nfunction insertionSort(array) {\n  let temp;\n  let pass;\n  let i;\n  const { length } = array;\n  for (pass = 1; pass < length; pass++) {\n    temp = array[pass];\n    i = pass - 1;\n    while (array[i] > temp && i >= 0) {\n      array[i + 1] = array[i];\n      i--;\n    }\n    array[i + 1] = temp;\n  }\n}\n\n// 10.8 Shell sort\nfunction shellSort(array) {\n  let temp;\n  let pass;\n  let gap;\n  let i;\n  const { length } = array;\n  for (gap = Math.floor(length / 2); gap > 0; gap = Math.floor(gap / 2)) {\n    // Modified Insersion Sort\n    for (pass = gap; pass < length; pass++) {\n      temp = array[pass];\n      i = pass - gap;\n      while (array[i] > temp && i >= 0) {\n        array[i + gap] = array[i];\n        i -= gap;\n      }\n      array[i + gap] = temp;\n    }\n  }\n}\n\n// Shell sort as per the Karumanchi book version\nfunction shellSortByKarumanchi(array) {\n  let i;\n  let j;\n  let h;\n  let v;\n  const { length } = array;\n  for (h = 1; h < length / 9; h = 3 * h + 1);\n  for (; h > 0; h = Math.floor(h / 3)) {\n    for (i = h + 1; i < length; i++) {\n      v = array[i];\n      j = i;\n      while (j >= h && array[j - h] > v) {\n        array[j] = array[j - h];\n        j -= h;\n      }\n      array[j] = v;\n    }\n  }\n}\n\n// 10.9 Merge sort\nfunction mergeSort(array, temp, left, right) {\n  let mid;\n  temp = (temp === undefined) ? [] : temp;\n  left = (left === undefined) ? 0 : left;\n  right = (right === undefined) ? (array.length - 1) : right;\n  if (left < right) {\n    mid = (left + right) / 2;\n    mid = Math.floor(mid);\n    mergeSort(array, temp, left, mid);\n    mergeSort(array, temp, mid + 1, right);\n    merge(array, temp, left, mid + 1, right);\n  }\n}\n\nfunction merge(array, temp, left, mid, right) {\n  let i;\n  const left_end = mid - 1;\n  let temp_pos = left;\n  const size = right - left + 1;\n  while ((left <= left_end) && (mid <= right)) {\n    if (array[left] <= array[mid]) {\n      temp[temp_pos++] = array[left++];\n    } else {\n      temp[temp_pos++] = array[mid++];\n    }\n  }\n  while (left <= left_end) {\n    temp[temp_pos++] = array[left++];\n  }\n  while (mid <= right) {\n    temp[temp_pos++] = array[mid++];\n  }\n  for (i = 0; i <= size; i++) {\n    array[right] = temp[right];\n    right--;\n  }\n}\n\n// 10.11 Quicksort\nfunction quickSort(array, low, high) {\n  let pivot;\n  low = (low === undefined) ? 0 : low;\n  high = (high === undefined) ? (array.length - 1) : high;\n  if (high > low) {\n    pivot = partition(array, low, high);\n    quickSort(array, low, pivot - 1);\n    quickSort(array, pivot + 1, high);\n  }\n}\n\nfunction partition(array, low, high) {\n  let left = low;\n  let right = high;\n  const pivot_item = array[low];\n  while (left < right) {\n    while (array[left] <= pivot_item) {\n      left++;\n    }\n    while (array[right] > pivot_item) {\n      right--;\n    }\n    if (left < right) {\n      swap(array, left, right);\n    }\n  }\n  array[low] = array[right];\n  array[right] = pivot_item;\n  return right;\n}\n\n// 10.15 Counting sort\nfunction countingSort(array, limit, exp) {\n  let i;\n  const temp = [];\n  const result = [];\n  const { length } = array;\n  exp = exp || 1;\n  if (limit === undefined) {\n    limit = getMax(array) + 1;\n  }\n  // complexity O(limit)\n  for (i = 0; i < limit; i++) {\n    temp[i] = 0;\n  }\n  // complexity O(length)\n  for (i = 0; i < length; i++) {\n    // temp[array[i]]++;\n    // modified for radix sort\n    temp[(array[i] / exp) % limit]++;\n  }\n  // complexity O(limit)\n  for (i = 1; i < limit; i++) {\n    temp[i] += temp[i - 1];\n  }\n  // complexity O()\n  for (i = length - 1; i >= 0; i--) {\n    // result[temp[array[i]] - 1] = array[i];\n    // modified for radix sort\n    result[temp[(array[i] / exp) % limit] - 1] = array[i];\n    // temp[array[i]]--;\n    // modified for radix sort\n    temp[(array[i] / exp) % limit]--;\n  }\n  // modified array to get the result\n  for (i = 0; i < length; i++) {\n    array[i] = result[i];\n  }\n}\n\n// 10.16 Bucket sort\nfunction bucketSort(array, BUCKET) {\n  let i;\n  let j;\n  let k;\n  const buckets = [];\n  const { length } = array;\n  if (BUCKET === undefined) {\n    BUCKET = getMax(array) + 1;\n  }\n  // complexity O(BUCKET)\n  for (i = 0; i < BUCKET; i++) {\n    buckets[i] = 0;\n  }\n  // complexity O(length)\n  for (i = 0; i < length; i++) {\n    buckets[array[i]]++;\n  }\n  for (i = 0, j = 0; j < BUCKET; j++) {\n    for (k = buckets[j]; k > 0; k--) {\n      array[i++] = j;\n    }\n  }\n}\n\n// 10.17 Radix sort\nfunction radixSort(array) {\n  let exp;\n  const max = getMax(array);\n  console.log(max);\n  for (exp = 1; Math.floor(max / exp) > 0; exp *= 10) {\n    countingSort(array, 10, exp);\n  }\n}\n\n// Problem-1 Given an array of n numbers containing repetition of some numbers. Check whether there are repeated elements or not.\n// Assume that we are not allowed to use additional space (but we can use temporary variables, O(1) storage).\nfunction checkDuplicatesInArray(array) {\n  let i;\n  let j;\n  const { length } = array;\n  for (i = 0; i < length - 1; i++) {\n    for (j = i + 1; j < length; j++) {\n      if (array[i] === array[j]) { return true; }\n    }\n  }\n  return false;\n}\n\n// Problem-2 Can we improve the time complexity of Problem-1\n// Use Heap-Sort as it have O(n log n) running complexity and use O(1) additional space.\n// We may also use Shell-Sort as it have O(n log^2 n) running time and O(1) additional space complexity.\nfunction improvedCheckDuplicatesInArray(array) {\n  let i;\n  const { length } = array;\n  shellSort(array);\n  for (i = 0; i < length - 1; i++) {\n    if (array[i] === array[i + 1]) { return true; }\n  }\n  return false;\n}\n\n// Problem-3 Given an array, where each element represents a vote in the election. Assume that each vote is given as an integer\n// representation the ID of chosen candidate. Give an algorithm for determining who wins the election.\nfunction checkWhoWinsTheElection(array) {\n  let i;\n  let j;\n  let counter;\n  let maxCounter = 0;\n  let candidate = array[0];\n  const { length } = array;\n  for (i = 0; i < length; i++) {\n    counter = 0;\n    for (j = i + 1; j < length; j++) {\n      if (array[i] === array[j]) {\n        counter++;\n      }\n    }\n    if (counter > maxCounter) {\n      candidate = array[i];\n      maxCounter = counter;\n    }\n  }\n  return candidate;\n}\n\n// Problem-4 Can we improve the complexity of Problem-3\nfunction improvedCheckWhoWinsTheElection(array) {\n  let i;\n  let j;\n  let candidate;\n  let counter = 0;\n  let maxCounter = 0;\n  let currentCandidate = array[0];\n  const { length } = array;\n  shellSort(array);\n  for (i = 1; i < length; i++) {\n    if (array[i] === currentCandidate) {\n      counter++;\n    } else {\n      currentCandidate = array[i];\n      counter = 0;\n    }\n    if (counter > maxCounter) {\n      maxCounter = counter;\n      candidate = currentCandidate;\n    }\n  }\n}\n\n// Problem-5 Can we further improve complexity of Problem-3\n// Use Counting-Sort as no of candidates will be very less compare to votes.\n\n// Problem-9 Let A and B be two arrays and there is a number K.\n// Give an algorithm to determine whether there exist a->A and b->B such that a+b=K in O(n log n) times.\n// For the given problem, we must have Binary search algorith.\n\n// Problem-16 Sort an array of 0's, 1's and 2's.\n// We can use Counting-Sort as it have only 3 elements. Complexity O(n)\n// We can also use Quick-Sort by using 1 as pivot element. This will move all 0's before 1 and all 2's after 1.\n// Hence the complexity of using Quick-Sort become O(n).\n\n// Problem-18 How to find the number which appeared maximum number of times in array?\nfunction numberAppearedMaximum(array) {\n  let i;\n  let number;\n  let count = 1;\n  let max = 1;\n  const { length } = array;\n  quickSort(array);\n  for (i = 1; i < length; i++) {\n    if (array[i] === array[i - 1]) {\n      count++;\n    } else {\n      if (max < count) {\n        max = count;\n        number = array[i - 1];\n      }\n      count = 1;\n    }\n  }\n  console.log('Number:', number, 'Count:', max);\n}\n","C:\\Users\\ankur\\Documents\\GitHub\\DataStructureAndAlgorithmsMadeEasyInJavaScript\\madeeasy\\chapter 11.js",["75","76","77","78","79","80","81","82","83","84","85","86","87","88","89","90","91","92","93","94","95","96","97","98","99","100","101","102","103","104","105","106","107","108","109"],"// 11.3 Types of Searching\n\n// Unordered linear search\nfunction unorderedLinearSearch(array, item) {\n  // will return either array index where item is located or -1 for not found\n  let i;\n  const { length } = array;\n  for (i = 0; i < length; i++) {\n    if (array[i] === item) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n// Ordered linear search\nfunction orderedLinearSearch(array, item) {\n  // will return either array index where item is located or -1 for not found\n  let i;\n  const { length } = array;\n  for (i = 0; i < length; i++) {\n    if (array[i] === item) {\n      return i;\n    } if (array[i] > item) {\n      // just improved the not found senario\n      // running time is almost same as of previous algo\n      return -1;\n    }\n  }\n  return -1;\n}\n\n// Binary search iterative version\nfunction binarySearchIterative(array, item) {\n  let low = 0;\n  let mid;\n  let high = array.length - 1;\n  while (low <= high) {\n    mid = low + Math.floor((high - low) / 2);\n    if (array[mid] === item) {\n      return mid;\n    } if (array[mid] < item) {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n  return -1;\n}\n\n// Binary search recursive version\nfunction binarySearchRecursive(array, item, low, high) {\n  let mid;\n  low = (low === undefined) ? 0 : low;\n  high = (high === undefined) ? (array.length - 1) : high;\n  if (low > high) {\n    return -1;\n  }\n  mid = low + Math.floor((high - low) / 2);\n  if (array[mid] === item) {\n    return mid;\n  } if (array[mid] < item) {\n    binarySearchRecursive(array, item, mid + 1, high);\n  } else {\n    binarySearchRecursive(array, item, low, mid - 1);\n  }\n}\n\n// Problem-1 Given an array of n numbers containing repetition of some numbers. Check whether there are repeated elements or not.\n// Same problem is given in sorting (chapter 10) as problem-1\n\n// Problem-4 Can we improve the complexity of problem-1 solution? Assume that array have all +ve numbers and all numbers are from rangle [0, n-1]\nfunction checkDuplicatesInArrayWithAsssumptionOfValues(array) {\n  let i;\n  const { length } = array;\n  for (i = 0; i < length - 1; i++) {\n    if (array[Math.abs(array[i])] < 0) {\n      return true;\n    }\n    array[array[i]] = -array[array[i]];\n  }\n  return false;\n}\n\n// Problem-5 Given an array with n numbers. Give an algorithm for finding the element which appears maximum number of times in array?\n// Same problem is given in sorting (chapter 10) as problem-3 but with different statement.\n\n// Problem-8 For Problem-5 solution, can we improve the time complexity? Assume that array have all numbers are from rangle [0, n-1]\nfunction maxRepetitionsWithAsssumptionOfValues(array) {\n  let i = 0;\n  let max = 0;\n  let maxIndex = 0;\n  const { length } = array;\n  for (i = 0; i < length; i++) {\n    array[array[i] % length] += length;\n  }\n  for (i = 0; i < length; i++) {\n    if (array[i] / n > max) {\n      max = array[i] / n;\n      maxIndex = i;\n    }\n  }\n  return i;\n}\n\n// Problem-9 Given the array of n numbers, give an algorithm to find first element in the array which is repeated.\n// Brute-force method\nfunction firstRepeatBruteForce(array) {\n  let i;\n  let j;\n  const { length } = array;\n  for (i = 0; i < length - 1; i++) {\n    for (j = i + 1; j < length; j++) {\n      if (array[i] === array[j]) {\n        return array[i];\n      }\n    }\n  }\n}\n\n// Problem-10 For Problem-9, can we use sorting technique?\n// No, as sorting will not maintain the sequence.\n\n// Problem-11 For Problem-9, can we use hashing technique?\n// Yes, but simple hashing technique will not work.\n\n// Problem-13 Finding the missing number: We are given an array of n-1 size and have numbers from 1 to n.\n// There are no duplicates in the list. One of the number is missing. Give an algo to find that missing number.\n// Brute-force method\nfunction findMissingNumberBruteForse(array, limit) {\n  let i;\n  let j;\n  let found;\n  const { length } = array;\n  if (limit === undefined) {\n    limit = getMax(array);\n  }\n  for (i = 1; i <= limit; i++) {\n    found = false;\n    for (j = 0; j < length; j++) {\n      if (array[j] === i) {\n        found = true;\n      }\n    }\n    if (!found) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n// Problem-14 For Problem-13, can we use sorting technique?\nfunction findMissingNumberUsingSorting(array, limit) {\n  let i;\n  const { length } = array;\n  if (limit === undefined) {\n    limit = getMax(array);\n  }\n  // We are using bucket sort as it have very less complexity and suitable for the given condition\n  bucketSort(array, limit + 1);\n  for (i = 0; i < length; i++) {\n    if (array[i] !== i + 1) {\n      return i + 1;\n    }\n  }\n  return -1;\n}\n\n// Problem-16 For Problem-13, can we improve the complexity?\nfunction improvedFindMissingNumber(array, limit) {\n  let i;\n  let numb;\n  let sum = 0;\n  const { length } = array;\n  if (limit === undefined) {\n    limit = getMax(array);\n  }\n  // Sum of 1 to n numbers are n*(n+1)/2\n  for (i = 0; i < length; i++) {\n    sum += array[i];\n  }\n  numb = (limit * (limit + 1)) / 2 - sum;\n  return numb || -1;\n}\n\n// Problem-17 In Problem-13, if the sum of the numbers goes beyond maximum allowed integers, then there can be integer\n// overflow and may not get correct answer. How can we solve the problem?\n// Sol: There is no integer in javascript but just number. However the solution of XOR is the anwser and still work here.\nfunction findMissingNumberUsingXOR(array, limit) {\n  let i;\n  let X;\n  let Y;\n  const { length } = array;\n  if (limit === undefined) {\n    limit = getMax(array);\n  }\n  for (i = 0; i < length; i++) {\n    X ^= array[i];\n  }\n  for (i = 1; i <= limit; i++) {\n    Y ^= i;\n  }\n  return X ^ Y;\n}\n\n// Problem-18 Find the number occuring odd number of times. Given an array of positive integers, all numbers occurs even\n// numbers of times except one number which occure odd number of times. Find the number in O(n) time and constant space.\nfunction findNumberOccurOddTimesUsingXOR(array) {\n  let i;\n  let X;\n  const { length } = array;\n  for (i = 0; i < length; i++) {\n    X ^= array[i];\n  }\n  return X;\n}\n\n// Problem-19 Find the two repeating elements in a given array: Given an array with n+2 elements, all elements of the array\n// are in range 1 to n and also only once except two numbers which occurs twice. Find those two numbers.\nfunction printRepeatedElementsUsingBruteForce(array, n) {\n  let i;\n  let j;\n  for (i = 0; i < n + 1; i++) {\n    for (j = i + 1; j < n + 2; j++) {\n      if (array[i] === array[j]) {\n        console.log(array[i]);\n      }\n    }\n  }\n}\n\n// Problem-20 For the Problem-19, can we improve the time complexity using sorting\nfunction printRepeatedElementsUsingSorting(array, n) {\n  let i;\n  bucketSort(array, n + 2);\n  for (i = 0; i < n + 1; i++) {\n    if (array[i] === array[i + 1]) {\n      console.log(array[i]);\n      i++;\n    }\n  }\n}\n\n// Problem-21 For the Problem-19, can we improve the time complexity using counting\nfunction printRepeatedElementUsingCounting(array, n) {\n  let i;\n  const count = [];\n  for (i = 0; i < n; i++) {\n    count[i] = 0;\n  }\n  for (i = 0; i < n + 2; i++) {\n    count[array[i]]++;\n    if (count[array[i]] === 2) {\n      console.log(array[i]);\n    }\n  }\n}\n\n// Problem-22 For the Problem-19, can we improve the time complexity using XOR operation\nfunction printRepeatedElementsUsingXOR(array, n) {\n  let i;\n  let right_most;\n  let X = 0;\n  let Y = 0;\n  let XOR = array[0];\n  for (i = 1; i < n + 2; i++) {\n    XOR ^= array[i]; // Compute XOR of all elements in array\n  }\n  for (i = 1; i <= n; i++) {\n    XOR ^= i; // Compute XOR of all elements from 1 to n\n  }\n  right_most = XOR & ~(XOR - 1); // Get the rightmost set bit in right_most\n\n  // Now divide elements in two sets by comparing rightmost set\n  for (i = 0; i < n + 2; i++) {\n    if (array[i] & right_most) {\n      X ^= array[i]; // XOR of first set in array\n    } else {\n      Y ^= array[i]; // XOR of second set in array\n    }\n  }\n\n  for (i = 1; i <= n; i++) {\n    if (i & right_most) {\n      X ^= i; // XOR of first set in array and {1,2,..,n}\n    } else {\n      Y ^= i; // XOR of second set in array and {1,2,..,n}\n    }\n  }\n  console.log(X, Y);\n}\n\n// Problem-23 For the Problem-19, is there yet another way of solving the problem\nfunction printRepeatedElementsUsingSP(array, n) {\n  let i;\n  let D;\n  let S = 0;\n  let P = 1; // Dfor difference, S for sum and P for product\n  for (i = 0; i < n + 2; i++) {\n    S += array[i];\n    P *= array[i];\n  }\n  S -= (n * (n + 1) / 2);\n  P /= Fact(n);\n  D = Math.sqrt(S * S - 4 * P);\n\n  console.log((S - D) / 2, (S + D) / 2);\n}\n","C:\\Users\\ankur\\Documents\\GitHub\\DataStructureAndAlgorithmsMadeEasyInJavaScript\\madeeasy\\chapter 19.js",[],{"ruleId":"110","severity":2,"message":"111","line":1,"column":10,"nodeType":"112","endLine":1,"endColumn":18},{"ruleId":"113","severity":2,"message":"114","line":28,"column":7,"nodeType":"115","messageId":"116","endLine":28,"endColumn":27},{"ruleId":"113","severity":2,"message":"114","line":64,"column":7,"nodeType":"115","messageId":"116","endLine":64,"endColumn":27},{"ruleId":"113","severity":2,"message":"114","line":109,"column":7,"nodeType":"115","messageId":"116","endLine":109,"endColumn":19},{"ruleId":"113","severity":2,"message":"117","line":277,"column":7,"nodeType":"115","messageId":"116","endLine":277,"endColumn":42},{"ruleId":"113","severity":2,"message":"118","line":312,"column":7,"nodeType":"115","messageId":"116","endLine":312,"endColumn":42},{"ruleId":"113","severity":2,"message":"114","line":413,"column":9,"nodeType":"115","messageId":"116","endLine":413,"endColumn":20},{"ruleId":"113","severity":2,"message":"114","line":421,"column":9,"nodeType":"115","messageId":"116","endLine":421,"endColumn":20},{"ruleId":"113","severity":2,"message":"114","line":422,"column":9,"nodeType":"115","messageId":"116","endLine":422,"endColumn":21},{"ruleId":"113","severity":2,"message":"119","line":431,"column":9,"nodeType":"115","messageId":"116","endLine":431,"endColumn":34},{"ruleId":"113","severity":2,"message":"119","line":437,"column":9,"nodeType":"115","messageId":"116","endLine":437,"endColumn":34},{"ruleId":"113","severity":2,"message":"119","line":438,"column":9,"nodeType":"115","messageId":"116","endLine":438,"endColumn":21},{"ruleId":"113","severity":2,"message":"114","line":542,"column":9,"nodeType":"115","messageId":"116","endLine":542,"endColumn":20},{"ruleId":"113","severity":2,"message":"114","line":550,"column":9,"nodeType":"115","messageId":"116","endLine":550,"endColumn":20},{"ruleId":"113","severity":2,"message":"114","line":563,"column":9,"nodeType":"115","messageId":"116","endLine":563,"endColumn":20},{"ruleId":"113","severity":2,"message":"114","line":564,"column":9,"nodeType":"115","messageId":"116","endLine":564,"endColumn":21},{"ruleId":"113","severity":2,"message":"119","line":573,"column":9,"nodeType":"115","messageId":"116","endLine":573,"endColumn":34},{"ruleId":"113","severity":2,"message":"119","line":579,"column":9,"nodeType":"115","messageId":"116","endLine":579,"endColumn":34},{"ruleId":"113","severity":2,"message":"119","line":585,"column":9,"nodeType":"115","messageId":"116","endLine":585,"endColumn":36},{"ruleId":"113","severity":2,"message":"119","line":586,"column":9,"nodeType":"115","messageId":"116","endLine":586,"endColumn":21},{"ruleId":"113","severity":2,"message":"120","line":613,"column":3,"nodeType":"115","messageId":"116","endLine":644,"endColumn":5},{"ruleId":"113","severity":2,"message":"114","line":633,"column":9,"nodeType":"115","messageId":"116","endLine":633,"endColumn":20},{"ruleId":"110","severity":2,"message":"111","line":1,"column":10,"nodeType":"112","endLine":1,"endColumn":18},{"ruleId":"110","severity":2,"message":"121","line":2,"column":10,"nodeType":"112","endLine":2,"endColumn":17},{"ruleId":"113","severity":2,"message":"122","line":47,"column":7,"nodeType":"115","messageId":"116","endLine":47,"endColumn":19},{"ruleId":"113","severity":2,"message":"122","line":112,"column":7,"nodeType":"115","messageId":"116","endLine":112,"endColumn":19},{"ruleId":"113","severity":2,"message":"122","line":146,"column":7,"nodeType":"115","messageId":"116","endLine":146,"endColumn":19},{"ruleId":"113","severity":2,"message":"122","line":190,"column":7,"nodeType":"115","messageId":"116","endLine":190,"endColumn":36},{"ruleId":"123","severity":2,"message":"124","line":137,"column":5,"nodeType":"112","messageId":"125","endLine":137,"endColumn":10},{"ruleId":"126","severity":2,"message":"127","line":143,"column":9,"nodeType":"112","messageId":"128","endLine":143,"endColumn":17},{"ruleId":"126","severity":2,"message":"129","line":144,"column":7,"nodeType":"112","messageId":"128","endLine":144,"endColumn":15},{"ruleId":"126","severity":2,"message":"127","line":146,"column":19,"nodeType":"112","messageId":"128","endLine":146,"endColumn":27},{"ruleId":"126","severity":2,"message":"129","line":148,"column":12,"nodeType":"112","messageId":"128","endLine":148,"endColumn":20},{"ruleId":"126","severity":2,"message":"129","line":150,"column":12,"nodeType":"112","messageId":"128","endLine":150,"endColumn":20},{"ruleId":"126","severity":2,"message":"127","line":153,"column":18,"nodeType":"112","messageId":"128","endLine":153,"endColumn":26},{"ruleId":"126","severity":2,"message":"129","line":154,"column":10,"nodeType":"112","messageId":"128","endLine":154,"endColumn":18},{"ruleId":"126","severity":2,"message":"129","line":157,"column":10,"nodeType":"112","messageId":"128","endLine":157,"endColumn":18},{"ruleId":"123","severity":2,"message":"130","line":171,"column":13,"nodeType":"112","messageId":"125","endLine":171,"endColumn":22},{"ruleId":"126","severity":2,"message":"131","line":180,"column":9,"nodeType":"112","messageId":"128","endLine":180,"endColumn":19},{"ruleId":"126","severity":2,"message":"131","line":182,"column":27,"nodeType":"112","messageId":"128","endLine":182,"endColumn":37},{"ruleId":"126","severity":2,"message":"131","line":185,"column":27,"nodeType":"112","messageId":"128","endLine":185,"endColumn":37},{"ruleId":"126","severity":2,"message":"131","line":193,"column":18,"nodeType":"112","messageId":"128","endLine":193,"endColumn":28},{"ruleId":"113","severity":2,"message":"132","line":52,"column":10,"nodeType":"133","messageId":"134","endLine":52,"endColumn":31},{"ruleId":"135","severity":2,"message":"136","line":59,"column":3,"nodeType":"112","messageId":"137","endLine":59,"endColumn":6},{"ruleId":"138","severity":2,"message":"139","line":98,"column":20,"nodeType":"112","messageId":"140","endLine":98,"endColumn":21},{"ruleId":"138","severity":2,"message":"139","line":99,"column":24,"nodeType":"112","messageId":"140","endLine":99,"endColumn":25},{"ruleId":"113","severity":2,"message":"141","line":108,"column":10,"nodeType":"133","messageId":"134","endLine":108,"endColumn":31},{"ruleId":"138","severity":2,"message":"142","line":136,"column":13,"nodeType":"112","messageId":"140","endLine":136,"endColumn":19},{"ruleId":"138","severity":2,"message":"142","line":157,"column":13,"nodeType":"112","messageId":"140","endLine":157,"endColumn":19},{"ruleId":"138","severity":2,"message":"143","line":160,"column":3,"nodeType":"112","messageId":"140","endLine":160,"endColumn":13},{"ruleId":"138","severity":2,"message":"142","line":176,"column":13,"nodeType":"112","messageId":"140","endLine":176,"endColumn":19},{"ruleId":"135","severity":2,"message":"144","line":182,"column":3,"nodeType":"112","messageId":"137","endLine":182,"endColumn":7},{"ruleId":"138","severity":2,"message":"142","line":195,"column":13,"nodeType":"112","messageId":"140","endLine":195,"endColumn":19},{"ruleId":"145","severity":2,"message":"146","line":198,"column":5,"nodeType":"147","messageId":"148","endLine":198,"endColumn":18},{"ruleId":"145","severity":2,"message":"146","line":201,"column":5,"nodeType":"147","messageId":"148","endLine":201,"endColumn":11},{"ruleId":"145","severity":2,"message":"149","line":203,"column":10,"nodeType":"150","messageId":"148","endLine":203,"endColumn":15},{"ruleId":"145","severity":2,"message":"146","line":213,"column":5,"nodeType":"147","messageId":"148","endLine":213,"endColumn":18},{"ruleId":"138","severity":2,"message":"143","line":235,"column":3,"nodeType":"112","messageId":"140","endLine":235,"endColumn":13},{"ruleId":"126","severity":2,"message":"151","line":262,"column":7,"nodeType":"112","messageId":"128","endLine":262,"endColumn":17},{"ruleId":"145","severity":2,"message":"146","line":267,"column":5,"nodeType":"147","messageId":"148","endLine":267,"endColumn":20},{"ruleId":"145","severity":2,"message":"146","line":270,"column":5,"nodeType":"147","messageId":"148","endLine":270,"endColumn":13},{"ruleId":"126","severity":2,"message":"151","line":272,"column":3,"nodeType":"112","messageId":"128","endLine":272,"endColumn":13},{"ruleId":"135","severity":2,"message":"152","line":272,"column":3,"nodeType":"112","messageId":"137","endLine":272,"endColumn":13},{"ruleId":"145","severity":2,"message":"153","line":272,"column":16,"nodeType":"150","messageId":"148","endLine":272,"endColumn":32},{"ruleId":"145","severity":2,"message":"154","line":272,"column":22,"nodeType":"155","messageId":"148","endLine":272,"endColumn":32},{"ruleId":"145","severity":2,"message":"153","line":276,"column":9,"nodeType":"150","messageId":"148","endLine":276,"endColumn":30},{"ruleId":"126","severity":2,"message":"151","line":276,"column":20,"nodeType":"112","messageId":"128","endLine":276,"endColumn":30},{"ruleId":"145","severity":2,"message":"146","line":277,"column":7,"nodeType":"147","messageId":"148","endLine":277,"endColumn":20},{"ruleId":"145","severity":2,"message":"146","line":279,"column":7,"nodeType":"147","messageId":"148","endLine":279,"endColumn":20},{"ruleId":"145","severity":2,"message":"153","line":284,"column":9,"nodeType":"150","messageId":"148","endLine":284,"endColumn":23},{"ruleId":"126","severity":2,"message":"151","line":284,"column":13,"nodeType":"112","messageId":"128","endLine":284,"endColumn":23},{"ruleId":"145","severity":2,"message":"146","line":285,"column":7,"nodeType":"147","messageId":"148","endLine":285,"endColumn":13},{"ruleId":"145","severity":2,"message":"146","line":287,"column":7,"nodeType":"147","messageId":"148","endLine":287,"endColumn":13},{"ruleId":"156","severity":2,"message":"157","line":303,"column":11,"nodeType":"150","messageId":"158","endLine":303,"endColumn":12},{"ruleId":"156","severity":2,"message":"157","line":303,"column":21,"nodeType":"150","messageId":"158","endLine":303,"endColumn":22},{"ruleId":"138","severity":2,"message":"159","line":304,"column":8,"nodeType":"112","messageId":"140","endLine":304,"endColumn":12},{"ruleId":"135","severity":2,"message":"160","line":305,"column":3,"nodeType":"112","messageId":"137","endLine":305,"endColumn":4},"import/named","ListNode not found in './chapter 03'","Identifier","consistent-return","Method 'popFromStack' expected no return value.","ReturnStatement","unexpectedReturnValue","Method 'popFromAdvancedStack' expected no return value.","Method 'popFromImprovedStack' expected no return value.","Method 'top' expected no return value.","Function 'arrayWithMultipleStack' expected no return value.","LLStack not found in './chapter 04'","Method 'deQueue' expected no return value.","no-use-before-define","'merge' was used before it was defined.","usedBeforeDefined","camelcase","Identifier 'left_end' is not in camel case.","notCamelCase","Identifier 'temp_pos' is not in camel case.","'partition' was used before it was defined.","Identifier 'pivot_item' is not in camel case.","Expected to return a value at the end of function 'binarySearchRecursive'.","FunctionDeclaration","missingReturn","prefer-const","'mid' is never reassigned. Use 'const' instead.","useConst","no-undef","'n' is not defined.","undef","Expected to return a value at the end of function 'firstRepeatBruteForce'.","'getMax' is not defined.","'bucketSort' is not defined.","'numb' is never reassigned. Use 'const' instead.","no-bitwise","Unexpected use of '^='.","AssignmentExpression","unexpected","Unexpected use of '^'.","BinaryExpression","Identifier 'right_most' is not in camel case.","'right_most' is never reassigned. Use 'const' instead.","Unexpected use of '&'.","Unexpected use of '~'.","UnaryExpression","no-mixed-operators","Unexpected mix of '*' and '/'. Use parentheses to clarify the intended order of operations.","unexpectedMixedOperator","'Fact' is not defined.","'D' is never reassigned. Use 'const' instead."]