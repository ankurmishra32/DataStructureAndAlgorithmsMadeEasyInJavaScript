[{"C:\\Users\\ankur\\Documents\\GitHub\\DataStructureAndAlgorithmsMadeEasyInJavaScript\\madeeasy\\chapter 02.js":"1","C:\\Users\\ankur\\Documents\\GitHub\\DataStructureAndAlgorithmsMadeEasyInJavaScript\\madeeasy\\chapter 03.js":"2","C:\\Users\\ankur\\Documents\\GitHub\\DataStructureAndAlgorithmsMadeEasyInJavaScript\\madeeasy\\chapter 04.js":"3","C:\\Users\\ankur\\Documents\\GitHub\\DataStructureAndAlgorithmsMadeEasyInJavaScript\\madeeasy\\chapter 05.js":"4","C:\\Users\\ankur\\Documents\\GitHub\\DataStructureAndAlgorithmsMadeEasyInJavaScript\\madeeasy\\chapter 10.js":"5","C:\\Users\\ankur\\Documents\\GitHub\\DataStructureAndAlgorithmsMadeEasyInJavaScript\\madeeasy\\chapter 11.js":"6","C:\\Users\\ankur\\Documents\\GitHub\\DataStructureAndAlgorithmsMadeEasyInJavaScript\\madeeasy\\chapter 19.js":"7"},{"size":1642,"mtime":1628954084101,"results":"8","hashOfConfig":"9"},{"size":19162,"mtime":1628950953043,"results":"10","hashOfConfig":"9"},{"size":16541,"mtime":1628952944546,"results":"11","hashOfConfig":"9"},{"size":5064,"mtime":1628952865629,"results":"12","hashOfConfig":"9"},{"size":9289,"mtime":1628954001253,"results":"13","hashOfConfig":"9"},{"size":8546,"mtime":1628954065341,"results":"14","hashOfConfig":"9"},{"size":3805,"mtime":1568096954772,"results":"15","hashOfConfig":"9"},{"filePath":"16","messages":"17","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"vymg66",{"filePath":"18","messages":"19","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"20","messages":"21","errorCount":22,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"22"},{"filePath":"23","messages":"24","errorCount":6,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"25"},{"filePath":"26","messages":"27","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"28","messages":"29","errorCount":23,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"30","messages":"31","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"C:\\Users\\ankur\\Documents\\GitHub\\DataStructureAndAlgorithmsMadeEasyInJavaScript\\madeeasy\\chapter 02.js",[],"C:\\Users\\ankur\\Documents\\GitHub\\DataStructureAndAlgorithmsMadeEasyInJavaScript\\madeeasy\\chapter 03.js",[],"C:\\Users\\ankur\\Documents\\GitHub\\DataStructureAndAlgorithmsMadeEasyInJavaScript\\madeeasy\\chapter 04.js",["32","33","34","35","36","37","38","39","40","41","42","43","44","45","46","47","48","49","50","51","52","53"],"import { ListNode } from './chapter 03';\n// 4.6 Implementation\n// Simple Array Implementation of Stack\nfunction ArrayStack(size) {\n  // private\n  let top = -1;\n  const capacity = size;\n  const array = [];\n  return {\n    isEmpty() {\n      return (top === -1);\n    },\n    isStackFull() {\n      return (top === (capacity - 1));\n    },\n    pushInStack(data) {\n      if (this.isStackFull()) {\n        console.error('Stack Overflow');\n      } else {\n        array[++top] = data;\n      }\n    },\n    popFromStack() {\n      if (this.isEmpty()) {\n        console.error('Stack is Empty');\n        return;\n      }\n      return array[top--];\n    },\n  };\n}\n\n// Dynamic Array Implementation of Stack\n// In JavaScript, array is already dynamic in nature\nfunction DynArrayStack(size) {\n  // private\n  let top = -1;\n  let capacity = size;\n  const array = [];\n  return {\n    isEmpty() {\n      return top === -1;\n    },\n    isStackFull() {\n      return top === capacity - 1;\n    },\n    doubleStack() {\n      capacity *= 2;\n    },\n    deleteStack() {\n      top = -1;\n    },\n    pushInStack(data) {\n      if (this.isStackFull()) {\n        this.doubleStack();\n      }\n      array[++top] = data;\n    },\n    popFromStack() {\n      if (this.isEmpty()) {\n        console.error('Stack is Empty');\n        return;\n      }\n      return array[top--];\n    },\n  };\n}\n\n// Linked list implementation of Stack\nfunction LLStack() {\n  let temp;\n  let llNode;\n  let headNode = new ListNode();\n\n  return {\n    top() {\n      if (!headNode) {\n        return null;\n      }\n      return headNode.getData();\n    },\n    isEmpty() {\n      if (!headNode || !headNode.getData()) { return true; }\n      return false;\n    },\n    deleteStack() {\n      headNode = null;\n    },\n    pushInStack(data) {\n      if (!headNode) {\n        headNode = new ListNode();\n        headNode.setData(data);\n      } else if (!headNode.getData()) {\n        headNode.setData(data);\n      } else {\n        llNode = new ListNode();\n        llNode.setData(data);\n        llNode.setNext(headNode);\n        headNode = llNode;\n      }\n    },\n    popFromStack() {\n      if (headNode === null) {\n        console.error('Stack is Empty');\n        return;\n      }\n      temp = headNode.getData();\n      headNode = headNode.getNext();\n      return temp;\n    },\n  };\n}\n\n//----------\n// Problem-2 Infix to Postfix conversion using stack\nfunction infix2postfix(infix) {\n  let i;\n  let bwParnt;\n  let postfix = '';\n  const operator = new LLStack();\n  for (i = 0; i < infix.length; i++) {\n    if ((infix.charCodeAt(i) >= 32 && infix.charCodeAt(i) <= 47)\n            || (infix.charCodeAt(i) >= 58 && infix.charCodeAt(i) <= 64)\n            || (infix.charCodeAt(i) >= 91 && infix.charCodeAt(i) <= 96)\n            || (infix.charCodeAt(i) >= 123 && infix.charCodeAt(i) <= 126)) {\n      if (infix[i] === ')') {\n        bwParnt = operator.popFromStack();\n        while (bwParnt !== '(') {\n          postfix += bwParnt;\n          bwParnt = operator.popFromStack();\n        }\n      } else {\n        operator.pushInStack(infix[i]);\n      }\n    } else {\n      postfix += infix[i];\n    }\n  }\n  while (!operator.isEmpty()) {\n    postfix += operator.popFromStack();\n  }\n  return postfix;\n}\n\n//----------\n// Problem-4 Postfix evaluation using stack\nfunction postfixEvaluation(postfix) {\n  let i;\n  const operand = new LLStack();\n  let evaluate;\n  let operand1;\n  let operand2;\n  for (i = 0; i < postfix.length; i++) {\n    if ((postfix.charCodeAt(i) >= 32 && postfix.charCodeAt(i) <= 47)\n            || (postfix.charCodeAt(i) >= 58 && postfix.charCodeAt(i) <= 64)\n            || (postfix.charCodeAt(i) >= 91 && postfix.charCodeAt(i) <= 96)\n            || (postfix.charCodeAt(i) >= 123 && postfix.charCodeAt(i) <= 126)) {\n      operand1 = parseInt(operand.popFromStack(), 10);\n      operand2 = parseInt(operand.popFromStack(), 10);\n      switch (postfix[i]) {\n        case '+':\n          evaluate = operand2 + operand1;\n          break;\n        case '-':\n          evaluate = operand2 - operand1;\n          break;\n        case '*':\n          evaluate = operand2 * operand1;\n          break;\n        case '/':\n          evaluate = operand2 / operand1;\n          break;\n        default:\n          console.error(\"Doesn't support oprand other then +, -, *, / \");\n          break;\n      }\n      operand.pushInStack(evaluate);\n    } else {\n      operand.pushInStack(postfix[i]);\n    }\n  }\n  return operand.popFromStack();\n}\n\n//----------\n// Problem-5 Infix evaluation using 2 stacks\nfunction infixEvaluation(infix) {\n  let i;\n  let bwParnt;\n  let evaluate;\n  let operand1;\n  let operand2;\n  const operand = new LLStack();\n  const operator = new LLStack();\n  for (i = 0; i < infix.length; i++) {\n    if ((infix.charCodeAt(i) >= 32 && infix.charCodeAt(i) <= 47)\n            || (infix.charCodeAt(i) >= 58 && infix.charCodeAt(i) <= 64)\n            || (infix.charCodeAt(i) >= 91 && infix.charCodeAt(i) <= 96)\n            || (infix.charCodeAt(i) >= 123 && infix.charCodeAt(i) <= 126)) {\n      if (infix[i] === ')') {\n        bwParnt = operator.popFromStack();\n        while (bwParnt !== '(') {\n          operand1 = parseInt(operand.popFromStack(), 10);\n          operand2 = parseInt(operand.popFromStack(), 10);\n          switch (operator.popFromStack()) {\n            case '+':\n              evaluate = operand2 + operand1;\n              break;\n            case '-':\n              evaluate = operand2 - operand1;\n              break;\n            case '*':\n              evaluate = operand2 * operand1;\n              break;\n            case '/':\n              evaluate = operand2 / operand1;\n              break;\n            default:\n              console.error(\"Doesn't support oprand other then +, -, *, / \");\n              break;\n          }\n          operand.pushInStack(evaluate);\n          bwParnt = operator.popFromStack();\n        }\n      } else {\n        operator.pushInStack(infix[i]);\n      }\n    } else {\n      operand.pushInStack(infix[i]);\n    }\n  }\n  while (!operator.isEmpty()) {\n    operand1 = parseInt(operand.popFromStack(), 10);\n    operand2 = parseInt(operand.popFromStack(), 10);\n    switch (operator.popFromStack()) {\n      case '+':\n        evaluate = operand2 + operand1;\n        break;\n      case '-':\n        evaluate = operand2 - operand1;\n        break;\n      case '*':\n        evaluate = operand2 * operand1;\n        break;\n      case '/':\n        evaluate = operand2 / operand1;\n        break;\n      default:\n        console.error(\"Doesn't support oprand other then +, -, *, / \");\n        break;\n    }\n    operand.pushInStack(evaluate);\n  }\n  return operand.popFromStack();\n}\n\n//----------\n// Problem-6 How to design a stack such that getMinimum() should be O(1)?\nfunction advancedStack() {\n  const elementStack = new LLStack();\n  const minStack = new LLStack();\n  return {\n    pushInAdvancedStack(data) {\n      elementStack.pushInStack(data);\n      if (minStack.isEmpty() || minStack.top() >= data) {\n        minStack.pushInStack(data);\n      } else {\n        minStack.pushInStack(minStack.top());\n      }\n    },\n    popFromAdvancedStack() {\n      if (elementStack.isEmpty()) {\n        console.error('Advanced stack is empty');\n        return;\n      }\n      minStack.popFromStack();\n      return elementStack.popFromStack();\n    },\n    getMinimum() {\n      return minStack.top();\n    },\n    getTop() {\n      return elementStack.top();\n    },\n  };\n}\n\n//----------\n// Problem-7 For the Problem-6 is it possible to improve the space complexity?\nfunction improvedStack() {\n  let minTop;\n  let elementTop;\n  const elementStack = new LLStack();\n  const minStack = new LLStack();\n  return {\n    pushInImprovedStack(data) {\n      elementStack.pushInStack(data);\n      if (minStack.isEmpty() || minStack.top() >= data) {\n        minStack.pushInStack(data);\n      }\n    },\n    popFromImprovedStack() {\n      if (elementStack.isEmpty()) {\n        console.log('Improved stack is empty');\n        return;\n      }\n      minTop = minStack.top();\n      elementTop = elementStack.top();\n      if (minTop === elementTop) {\n        minStack.popFromStack();\n      }\n      return elementStack.popFromStack();\n    },\n    getMinimum() {\n      return minStack.top();\n    },\n    getTop() {\n      return elementStack.top();\n    },\n  };\n}\n\n//----------\n// Problem-8 Given an array of characters formed with a's and b's. The string is marked with special character X\n// which represents the middle of the list. Check whether the string is palindrome or not?\nfunction isPalindrome(inputStr) {\n  let i = 0;\n  let j = inputStr.length - 1;\n  while ((i < j) && (inputStr[i] === inputStr[j])) {\n    i++;\n    j--;\n  }\n  if (i < j) {\n    console.error('Not a Palindrome');\n    return 0;\n  }\n  console.log('Palindrome');\n  return 1;\n}\n\n//----------\n// Problem-10 Can we solve Problem-8 using stacks?\nfunction isPalindromeUsingStack(inputStr) {\n  let i = 0;\n  const stack = new LLStack();\n  while (inputStr[i] !== 'X') {\n    stack.pushInStack(inputStr[i++]);\n  }\n  i++;\n  while (i < inputStr.length) {\n    if (stack.isEmpty()) {\n      return false;\n    }\n    if (inputStr[i++] !== stack.popFromStack()) {\n      return false;\n    }\n  }\n  return true;\n}\n\n//----------\n// Problem-11 Given a stack, how to reverse the contents of stacks by using only stack operations (push and pop)?\nfunction stackReversal() {\n  // private\n  function insertAtBottom(stack, data) {\n    if (stack.isEmpty()) {\n      stack.pushInStack(data);\n      return;\n    }\n    const temp = stack.popFromStack();\n    this.insertAtBottom(stack, data);\n    stack.pushInStack(temp);\n  }\n  return {\n    // public\n    reverseStack(stack) {\n      if (stack.isEmpty()) return;\n      const temp = stack.popFromStack();\n      this.reverseStack(stack);\n      insertAtBottom(stack, temp);\n    },\n  };\n}\n\n//----------\n// Problem-14 How do we implement 2 stack using only one array? Our stack routines shoulf not indicate an exception\n// unless every slot in the array is used?\nfunction arrayWithTwoStack(size) {\n  const dataArray = [];\n  let topOne = -1;\n  let topTwo = size;\n  return {\n    pushInStack(stackId, data) {\n      if (topTwo === topOne + 1) {\n        console.error('Array is full');\n        return;\n      }\n      if (stackId === 1) {\n        dataArray[++topOne] = data;\n      } else if (stackId === 2) {\n        dataArray[--topTwo] = data;\n      }\n    },\n\n    popFromStack(stackId) {\n      if (stackId === 1) {\n        if (topOne === -1) {\n          console.error('First Stack is empty');\n          return;\n        }\n        const top = dataArray[topOne];\n        dataArray[topOne--] = null;\n        return top;\n      } if (stackId === 2) {\n        if (topTwo === size) {\n          console.error('Second Stack is empty');\n          return;\n        }\n        const top = dataArray[topTwo];\n        dataArray[topTwo++] = null;\n        return top;\n      } return null;\n    },\n\n    top(stackId) {\n      if (stackId === 1) {\n        if (topOne === -1) {\n          console.error('First Stack is empty');\n          return;\n        }\n        return dataArray[topOne];\n      } if (stackId === 2) {\n        if (topTwo === size) {\n          console.error('Second Stack is empty');\n          return;\n        }\n        return dataArray[topTwo];\n      } return null;\n    },\n\n    isEmpty(stackId) {\n      if (stackId === 1) {\n        return topOne === -1;\n      } if (stackId === size) {\n        return topTwo === size;\n      } return null;\n    },\n  };\n}\n\n//----------\n// Problem-15 How do we implement 3 stack in one array?\nfunction arrayWithThreeStack(size) {\n  const dataArray = [];\n  let topOne = -1;\n  let topTwo = size;\n  let topThree = size / 2;\n  let baseThree = topThree;\n\n  function stack3IsLeftShiftable() {\n    if (topOne + 1 < baseThree) {\n      return true;\n    }\n    return false;\n  }\n\n  function shiftStack3Left() {\n    for (let i = baseThree - 1; i < topThree; i++) {\n      dataArray[i] = dataArray[i + 1];\n    }\n    console.log('Left shifted');\n    dataArray[topThree--] = null;\n    baseThree--;\n  }\n\n  function stack3IsRightShiftable() {\n    if (topTwo - 1 > topThree) {\n      return true;\n    }\n    return false;\n  }\n\n  function shiftStack3Right() {\n    for (let i = topThree + 1; i > baseThree; i--) {\n      dataArray[i] = dataArray[i - 1];\n    }\n    console.log('Right shifted');\n    dataArray[baseThree++] = null;\n    topThree++;\n  }\n\n  return {\n    pushInStack(stackId, data) {\n      if (stackId === 1) {\n        if (topOne + 1 === baseThree) {\n          if (stack3IsRightShiftable()) {\n            shiftStack3Right();\n            dataArray[++topOne] = data;\n          } else {\n            console.error('Stack 1 is reached its maximum limit');\n            return;\n          }\n        } else {\n          dataArray[++topOne] = data;\n        }\n      }\n      if (stackId === 2) {\n        if (topTwo - 1 === topThree) {\n          if (stack3IsLeftShiftable()) {\n            shiftStack3Left();\n            dataArray[--topTwo] = data;\n          } else {\n            console.error('Stack 2 is reached its maximum limit');\n            return;\n          }\n        } else {\n          dataArray[--topTwo] = data;\n        }\n      }\n      if (stackId === 3) {\n        if (topTwo - 1 === topThree) {\n          if (stack3IsLeftShiftable()) {\n            shiftStack3Left();\n            dataArray[++topThree] = data;\n          } else {\n            console.error('Stack 3 is reached its maximum limit');\n          }\n        } else {\n          dataArray[++topThree] = data;\n        }\n      }\n    },\n\n    popFromStack(stackId) {\n      if (stackId === 1) {\n        if (topOne === -1) {\n          console.error('First Stack is empty');\n          return;\n        }\n        const top = dataArray[topOne];\n        dataArray[topOne--] = null;\n        return top;\n      } if (stackId === 2) {\n        if (topTwo === size) {\n          console.error('Second Stack is empty');\n          return;\n        }\n        const top = dataArray[topTwo];\n        dataArray[topTwo++] = null;\n        return top;\n      } if (stackId === 3) {\n        if (topThree === size && dataArray[topThree] === null) {\n          console.error('Third Stack is empty');\n          return;\n        }\n        const top = dataArray[topThree];\n        if (topThree > baseThree) {\n          dataArray[topThree--] = null;\n        }\n        if (topThree === baseThree) {\n          dataArray[topThree] = null;\n        }\n        return top;\n      } return null;\n    },\n\n    top(stackId) {\n      if (stackId === 1) {\n        if (topOne === -1) {\n          console.error('First Stack is empty');\n          return;\n        }\n        return dataArray[topOne];\n      } if (stackId === 2) {\n        if (topTwo === size) {\n          console.error('Second Stack is empty');\n          return;\n        }\n        return dataArray[topTwo];\n      } if (stackId === 3) {\n        if (topThree === baseThree && dataArray[baseThree] === null) {\n          console.error('Third Stack is empty');\n          return;\n        }\n        return dataArray[topThree];\n      } return null;\n    },\n\n    isEmpty(stackId) {\n      if (stackId === 1) {\n        return topOne === -1;\n      } if (stackId === size) {\n        return topTwo === size;\n      } if (stackId === 3) {\n        return (topThree === baseThree && dataArray[baseThree] === null);\n      } return null;\n    },\n  };\n}\n\n//----------\n// Problem-17 Multiple (m) stack in one array: As similar to Problem-15, what if we want to implement m stacks in one array?\nfunction arrayWithMultipleStack(size, m) {\n  const dataArray = [];\n  const base = [];\n  let top = [];\n\n  if (size < m) {\n    console.error(`Size <${m} is not possible`);\n    return;\n  }\n\n  return {\n    pushInStack(stackId, data) {\n      for (let i = 0; i < size; i++) {\n        if (top[i] === base[i + 1]) {\n          // Print ith Stack is full and does the shifting\n          // TO-DO\n        } else {\n          dataArray[++top[i]] = data;\n        }\n      }\n    },\n\n    popFromStack(stackId) {\n      for (let i = 0; i < size; i++) {\n        if (top[i] === base[i]) {\n          console.error('Stack is empty');\n          return;\n        }\n        top = dataArray[top[i]];\n        dataArray[top[i]--] = null;\n        return top;\n      }\n    },\n\n    top(stackId) {\n      // TO-DO\n    },\n\n    isEmpty(stackId) {\n      // TO-DO\n    },\n  };\n}\n\n// Problem-18 Consider an empty stack of integers. Let the numbers 1,2,3,4,5,6 be pushed on to this stack only in the order they appear from left to right.\n// Let S indicates a push and X indicates a pop operation. Can the be permuted in to the order? If so, then give the order string of operation.\n\nexport default { LLStack };\n","C:\\Users\\ankur\\Documents\\GitHub\\DataStructureAndAlgorithmsMadeEasyInJavaScript\\madeeasy\\chapter 05.js",["54","55","56","57","58","59"],"import { ListNode } from './chapter 03';\nimport { LLStack } from './chapter 04';\n\n// 5.6 Implementation\n// Simple Circular Array Implementation of Queue\nfunction ArrayQueue(size) {\n  // private\n  let front = -1;\n  let rear = -1;\n  const capacity = size;\n  const array = [];\n  // closure\n  return {\n    isEmpty() {\n      return (front === -1);\n    },\n    isFull() {\n      return ((rear + 1) % capacity === front);\n    },\n    getQueueSize() {\n      return ((capacity - front + rear + 1) % capacity);\n    },\n    enQueue(data) {\n      if (this.isFull()) {\n        console.error('Queue overflow');\n        return;\n      }\n      rear = (rear + 1) % capacity;\n      array[rear] = data;\n      if (front === -1) {\n        front = rear;\n      }\n    },\n    deQueue() {\n      if (this.isEmpty()) {\n        console.error('Queue Empty');\n        return;\n      }\n      const data = array[front];\n      if (front === rear) {\n        // when only one element left in queue\n        front = -1;\n        rear = -1;\n      } else {\n        front = (front + 1) % capacity;\n      }\n      return data;\n    },\n  };\n}\n\n// Dynamic Circular Array Implementation of Queue\nfunction DynArrayQueue(size) {\n  // private\n  let front = -1;\n  let rear = -1;\n  let capacity = size;\n  const array = [];\n  // closure\n  return {\n    isEmpty() {\n      return (front === -1);\n    },\n    isFull() {\n      return ((rear + 1) % capacity === front);\n    },\n    getQueueSize() {\n      size = (capacity - front + rear + 1) % capacity;\n      /** Size will be zero when the queue get's full\n             * This time we have to double the size of array\n             * Hence the remaining size is equal to capacity\n             */\n      if (size === 0) {\n        size = capacity;\n      }\n      return size;\n    },\n    resizeQueue() {\n      const initCapacity = capacity;\n      capacity *= 2;\n      if (rear < front) {\n        for (let i = 0; i < front; i++) {\n          array[i + initCapacity] = array[i];\n          array[i] = undefined;\n        }\n        rear += initCapacity;\n      }\n    },\n    enQueue(data) {\n      if (this.isFull()) {\n        this.resizeQueue();\n      }\n      rear = (rear + 1) % capacity;\n      array[rear] = data;\n      if (front === -1) {\n        front = rear;\n      }\n    },\n    deQueue() {\n      if (this.isEmpty()) {\n        console.error('Queue Empty');\n        return;\n      }\n      const data = array[front];\n      if (front === rear) {\n        // when only one element left in queue\n        front = -1;\n        rear = -1;\n      } else {\n        front = (front + 1) % capacity;\n      }\n      return data;\n    },\n  };\n}\n\n// Linked List Implementation of Queue\nfunction LLQueue() {\n  let length = 0;\n  let frontNode = null;\n  let rearNode = null;\n  return {\n    isEmpty() {\n      return (frontNode === null);\n    },\n    enQueue(data) {\n      const newNode = new ListNode();\n      newNode.setData(data);\n      if (rearNode != null) {\n        rearNode.setNext(newNode);\n      }\n      rearNode = newNode;\n      if (frontNode === null) {\n        frontNode = rearNode;\n      }\n      length++;\n    },\n    deQueue() {\n      if (this.isEmpty()) {\n        console.error('Queue Empty');\n        return;\n      }\n      const data = frontNode.getData();\n      frontNode = frontNode.getNext();\n      length--;\n      return data;\n    },\n    getQueueSize() {\n      return length;\n    },\n  };\n}\n\n//----------\n// Problem-1 Give an algorithm for reversing a queue Q. To access the queue, you are only allowed to use the methods of queue ADT.\nfunction QueueReversal(queue) {\n  const stack = new LLStack();\n  while (!queue.isEmpty()) {\n    stack.pushInStack(queue.deQueue());\n  }\n  while (!stack.isEmpty()) {\n    queue.enQueue(stack.popFromStack());\n  }\n  return queue;\n}\n\n//----------\n// Problem-2 How to implement a queue using two stacks?\nfunction QueueWithTwoStacks() {\n  const stack1 = new LLStack();\n  const stack2 = new LLStack();\n\n  return {\n    isEmpty() {\n      if (stack2.isEmpty()) {\n        while (!stack1.isEmpty()) {\n          stack2.pushInStack(stack1.popFromStack());\n        }\n      }\n      return stack2.isEmpty();\n    },\n    enQueue(data) {\n      stack1.pushInStack(data);\n    },\n    deQueue() {\n      if (this.isEmpty()) {\n        console.error('Queue Empty');\n        return;\n      }\n      return stack2.popFromStack();\n    },\n  };\n}\n\n//----------\n// Problem-3 Show how to efficiently implement one stack using two queues.\nfunction StackWithTwoQueues() {\n  const queue1 = new LLQueue();\n  const queue2 = new LLQueue();\n\n  return {\n    pushInStack(data) {\n      if (queue1.isEmpty()) {\n        queue2.enQueue(data);\n      } else {\n        queue1.enQueue(data);\n      }\n    },\n    popFromStack() {\n      let i = 0;\n      let size;\n      if (queue2.isEmpty()) {\n        size = queue1.getQueueSize();\n        while (i++ < size - 1) {\n          queue2.enQueue(queue1.deQueue());\n        }\n        return queue1.deQueue();\n      }\n      size = queue2.getQueueSize();\n      while (i++ < size - 1) {\n        queue1.enQueue(queue2.deQueue());\n      }\n      return queue2.deQueue();\n    },\n  };\n}\n","C:\\Users\\ankur\\Documents\\GitHub\\DataStructureAndAlgorithmsMadeEasyInJavaScript\\madeeasy\\chapter 10.js",[],"C:\\Users\\ankur\\Documents\\GitHub\\DataStructureAndAlgorithmsMadeEasyInJavaScript\\madeeasy\\chapter 11.js",["60","61","62","63","64","65","66","67","68","69","70","71","72","73","74","75","76","77","78","79","80","81","82"],"C:\\Users\\ankur\\Documents\\GitHub\\DataStructureAndAlgorithmsMadeEasyInJavaScript\\madeeasy\\chapter 19.js",[],{"ruleId":"83","severity":2,"message":"84","line":1,"column":10,"nodeType":"85","endLine":1,"endColumn":18},{"ruleId":"86","severity":2,"message":"87","line":28,"column":7,"nodeType":"88","messageId":"89","endLine":28,"endColumn":27},{"ruleId":"86","severity":2,"message":"87","line":64,"column":7,"nodeType":"88","messageId":"89","endLine":64,"endColumn":27},{"ruleId":"86","severity":2,"message":"87","line":109,"column":7,"nodeType":"88","messageId":"89","endLine":109,"endColumn":19},{"ruleId":"86","severity":2,"message":"90","line":277,"column":7,"nodeType":"88","messageId":"89","endLine":277,"endColumn":42},{"ruleId":"86","severity":2,"message":"91","line":312,"column":7,"nodeType":"88","messageId":"89","endLine":312,"endColumn":42},{"ruleId":"86","severity":2,"message":"87","line":413,"column":9,"nodeType":"88","messageId":"89","endLine":413,"endColumn":20},{"ruleId":"86","severity":2,"message":"87","line":421,"column":9,"nodeType":"88","messageId":"89","endLine":421,"endColumn":20},{"ruleId":"86","severity":2,"message":"87","line":422,"column":9,"nodeType":"88","messageId":"89","endLine":422,"endColumn":21},{"ruleId":"86","severity":2,"message":"92","line":431,"column":9,"nodeType":"88","messageId":"89","endLine":431,"endColumn":34},{"ruleId":"86","severity":2,"message":"92","line":437,"column":9,"nodeType":"88","messageId":"89","endLine":437,"endColumn":34},{"ruleId":"86","severity":2,"message":"92","line":438,"column":9,"nodeType":"88","messageId":"89","endLine":438,"endColumn":21},{"ruleId":"86","severity":2,"message":"87","line":542,"column":9,"nodeType":"88","messageId":"89","endLine":542,"endColumn":20},{"ruleId":"86","severity":2,"message":"87","line":550,"column":9,"nodeType":"88","messageId":"89","endLine":550,"endColumn":20},{"ruleId":"86","severity":2,"message":"87","line":563,"column":9,"nodeType":"88","messageId":"89","endLine":563,"endColumn":20},{"ruleId":"86","severity":2,"message":"87","line":564,"column":9,"nodeType":"88","messageId":"89","endLine":564,"endColumn":21},{"ruleId":"86","severity":2,"message":"92","line":573,"column":9,"nodeType":"88","messageId":"89","endLine":573,"endColumn":34},{"ruleId":"86","severity":2,"message":"92","line":579,"column":9,"nodeType":"88","messageId":"89","endLine":579,"endColumn":34},{"ruleId":"86","severity":2,"message":"92","line":585,"column":9,"nodeType":"88","messageId":"89","endLine":585,"endColumn":36},{"ruleId":"86","severity":2,"message":"92","line":586,"column":9,"nodeType":"88","messageId":"89","endLine":586,"endColumn":21},{"ruleId":"86","severity":2,"message":"93","line":613,"column":3,"nodeType":"88","messageId":"89","endLine":644,"endColumn":5},{"ruleId":"86","severity":2,"message":"87","line":633,"column":9,"nodeType":"88","messageId":"89","endLine":633,"endColumn":20},{"ruleId":"83","severity":2,"message":"84","line":1,"column":10,"nodeType":"85","endLine":1,"endColumn":18},{"ruleId":"83","severity":2,"message":"94","line":2,"column":10,"nodeType":"85","endLine":2,"endColumn":17},{"ruleId":"86","severity":2,"message":"95","line":47,"column":7,"nodeType":"88","messageId":"89","endLine":47,"endColumn":19},{"ruleId":"86","severity":2,"message":"95","line":112,"column":7,"nodeType":"88","messageId":"89","endLine":112,"endColumn":19},{"ruleId":"86","severity":2,"message":"95","line":146,"column":7,"nodeType":"88","messageId":"89","endLine":146,"endColumn":19},{"ruleId":"86","severity":2,"message":"95","line":190,"column":7,"nodeType":"88","messageId":"89","endLine":190,"endColumn":36},{"ruleId":"83","severity":2,"message":"96","line":1,"column":10,"nodeType":"85","endLine":1,"endColumn":14},{"ruleId":"83","severity":2,"message":"97","line":2,"column":10,"nodeType":"85","endLine":2,"endColumn":16},{"ruleId":"83","severity":2,"message":"98","line":2,"column":18,"nodeType":"85","endLine":2,"endColumn":28},{"ruleId":"86","severity":2,"message":"99","line":55,"column":10,"nodeType":"100","messageId":"101","endLine":55,"endColumn":31},{"ruleId":"102","severity":2,"message":"103","line":100,"column":20,"nodeType":"85","messageId":"104","endLine":100,"endColumn":21},{"ruleId":"102","severity":2,"message":"103","line":101,"column":24,"nodeType":"85","messageId":"104","endLine":101,"endColumn":25},{"ruleId":"86","severity":2,"message":"105","line":110,"column":10,"nodeType":"100","messageId":"101","endLine":110,"endColumn":31},{"ruleId":"106","severity":2,"message":"107","line":199,"column":5,"nodeType":"108","messageId":"109","endLine":199,"endColumn":18},{"ruleId":"106","severity":2,"message":"107","line":202,"column":5,"nodeType":"108","messageId":"109","endLine":202,"endColumn":11},{"ruleId":"106","severity":2,"message":"110","line":204,"column":10,"nodeType":"111","messageId":"109","endLine":204,"endColumn":15},{"ruleId":"106","severity":2,"message":"107","line":214,"column":5,"nodeType":"108","messageId":"109","endLine":214,"endColumn":18},{"ruleId":"106","severity":2,"message":"107","line":267,"column":5,"nodeType":"108","messageId":"109","endLine":267,"endColumn":20},{"ruleId":"106","severity":2,"message":"107","line":270,"column":5,"nodeType":"108","messageId":"109","endLine":270,"endColumn":13},{"ruleId":"106","severity":2,"message":"112","line":272,"column":21,"nodeType":"111","messageId":"109","endLine":272,"endColumn":37},{"ruleId":"106","severity":2,"message":"113","line":272,"column":27,"nodeType":"114","messageId":"109","endLine":272,"endColumn":37},{"ruleId":"106","severity":2,"message":"112","line":276,"column":9,"nodeType":"111","messageId":"109","endLine":276,"endColumn":29},{"ruleId":"106","severity":2,"message":"107","line":277,"column":7,"nodeType":"108","messageId":"109","endLine":277,"endColumn":20},{"ruleId":"106","severity":2,"message":"107","line":279,"column":7,"nodeType":"108","messageId":"109","endLine":279,"endColumn":20},{"ruleId":"106","severity":2,"message":"112","line":284,"column":9,"nodeType":"111","messageId":"109","endLine":284,"endColumn":22},{"ruleId":"106","severity":2,"message":"107","line":285,"column":7,"nodeType":"108","messageId":"109","endLine":285,"endColumn":13},{"ruleId":"106","severity":2,"message":"107","line":287,"column":7,"nodeType":"108","messageId":"109","endLine":287,"endColumn":13},{"ruleId":"115","severity":2,"message":"116","line":302,"column":11,"nodeType":"111","messageId":"117","endLine":302,"endColumn":12},{"ruleId":"115","severity":2,"message":"116","line":302,"column":21,"nodeType":"111","messageId":"117","endLine":302,"endColumn":22},"import/named","ListNode not found in './chapter 03'","Identifier","consistent-return","Method 'popFromStack' expected no return value.","ReturnStatement","unexpectedReturnValue","Method 'popFromAdvancedStack' expected no return value.","Method 'popFromImprovedStack' expected no return value.","Method 'top' expected no return value.","Function 'arrayWithMultipleStack' expected no return value.","LLStack not found in './chapter 04'","Method 'deQueue' expected no return value.","Fact not found in './chapter 02'","getMax not found in './chapter 10'","bucketSort not found in './chapter 10'","Expected to return a value at the end of function 'binarySearchRecursive'.","FunctionDeclaration","missingReturn","no-undef","'n' is not defined.","undef","Expected to return a value at the end of function 'firstRepeatBruteForce'.","no-bitwise","Unexpected use of '^='.","AssignmentExpression","unexpected","Unexpected use of '^'.","BinaryExpression","Unexpected use of '&'.","Unexpected use of '~'.","UnaryExpression","no-mixed-operators","Unexpected mix of '*' and '/'. Use parentheses to clarify the intended order of operations.","unexpectedMixedOperator"]